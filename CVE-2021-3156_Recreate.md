---
layout: default
---

# Finding Vulnerability leading to CVE-2021-3156

# CVE Description

```text
Sudo before 1.9.5p2 contains an off-by-one error that can result in a heap-based buffer overflow,
which allows privilege escalation to root via "sudoedit -s" and a command-line argument that ends
with a single backslash character.
```

# Introduction

In this blog we will try to find the vulnerability leading to `CVE-2021-3156`. Originally this vulnerability was found using code audit by `Qualys`, but we will try to discover it using fuzzing and see how this vulnerability evaded detection for almost 10 years.

**NOTE:** For this blog we will be using `sudo v1.8.31`.

# Setup

We will try to find vulnerability using the `AFL++` fuzzer. But, in order to understand how to setup `sudo` for fuzzing let's disect the CVE decription first.

From the CVE description we can see that the vulnerability occurs when we use the `sudoedit` binary as opposed to `sudo`. Well it can be `blahblahedit` as long as long as last 4 characters are `edit`. We will look into why this is the case later in the blog. We also know that `sudoedit` requires a `-s` option followed by some characters that causes the crash. 

Do you see the problem here? AFL++ works best with applications that read from a `file` or `stdin`. But, here we need to fuzz the `command line arguments`. Fortunately, AFL++ provides code for doing exactly that:[argv_fuzzing](https://github.com/AFLplusplus/AFLplusplus/blob/78b7e14c73baacf1d88b3c03955e78f5080d17ba/utils/argv_fuzzing/README.md#L4).

Just add the following lines in `sudo.c` to enable argv fuzzing.

```c
#include "sudo.h"
#include "sudo_plugin.h"
#include "sudo_plugin_int.h"
#include "argv-fuzz-inl.h" // Include header file

/*
 * Local variables
 */
struct plugin_container policy_plugin;
struct plugin_container_list io_plugins = TAILQ_HEAD_INITIALIZER(io_plugins);

...

int
main(int argc, char *argv[], char *envp[])
{
    AFL_INIT_ARGV();  // enable argv_fuzzing
    int nargc, ok, status = 0;
    char **nargv, **env_add;
```

One thing to point out is that we will be fuzzing all the `cmdline args` including `argv[0]` and we will let the fuzzer do mutations to found the correct name that invokes `sudoedit` specific functionality. 

Now that we have setup `argv_fuzzing`, let's test it out. 

```bash
# argv_fuzzing requires NULL seperated args 
echo -ne "sudo\x00-l\x00" | ./sudoedit
```

We expect the output to be:

```bash
Matching Defaults entries for faran on faran:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, use_pty
 
User faran may run the following commands on faran:
    (ALL : ALL) ALL
```

But the output is:

```bash
sudoedit: Only one of the -e, -h, -i, -K, -l, -s, -v or -V options may be specified
usage: sudoedit [-AknS] [-C num] [-g group] [-h host] [-p prompt] [-T timeout] [-u user] file ..
```

Why does `sudoedit` still run when `argv[0]` is `sudo`?

It turns out that by default, `sudo` uses `HAVE___PROGNAME` to get the program name and not from `argv[0]` as shown in `progname.c`:

```c
oid
initprogname(const char *name)
{
# ifdef HAVE___PROGNAME
    extern const char *__progname;

    if (__progname != NULL && *__progname != '\0')
	progname = __progname;
    else
# endif
    if ((progname = strrchr(name, '/')) != NULL) {
	progname++;
    } else {
	progname = name;
    }
...
```
We need to remove the `HAVE___PROGNAME` and then it will take `argv[0]` as as program name. The program name is set at the very start of `main()` in `sudo.c`.

```c
int
main(int argc, char *argv[], char *envp[])
{
    int nargc, ok, status = 0;
    char **nargv, **env_add;
    
    ...

    initprogname(argc > 0 ? argv[0] : "sudo");

    /* Crank resource limits to unlimited. */
    unlimit_sudo();
```

Now, the programs `sudo` and `sudoedit` will work as expected. 

Before we compile the target and run the fuzzer there is one more thing to take care of. AFL++ is `root` owned and so is `sudo`. `sudo` behaves very differently when we a root user runs it. That is not what we want. We want to fuzz `sudo` being a non-root user just as `sudo` is used in normal case scenario. 

The way `sudo` determines the user type is in the `get_user_info()` function inside `sudo.c`.

```c
static char **
get_user_info(struct user_details *ud)
{
    char *cp, **user_info, path[PATH_MAX];
    unsigned int i = 0;
    mode_t mask;
    struct passwd *pw;
    
    ...

    if (user_info == NULL)
	goto oom;

    ud->pid = getpid();
    ud->ppid = getppid();
    
    ...

    ud->uid = getuid(); // hardcode to 1000
    ud->euid = geteuid();
    ud->gid = getgid(); // hardcode to 1000
    ud->egid = getegid();
```

The user information is get using `getuid(), geteuid(), getgid(), getegid()`. We hardcode the `uid and gid` to `1000` so that we always run sudo being a normal user.